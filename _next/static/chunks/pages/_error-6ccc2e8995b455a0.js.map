{"version":3,"file":"static/chunks/pages/_error-6ccc2e8995b455a0.js","mappings":"sFACKA,OAAOC,SAAWD,OAAOC,UAAY,IAAIC,KAAK,CAC7C,UACA,WACE,OAAO,EAAQ,W,yICIvBC,eAAeC,EAAgCC,GAC7C,MAAM,IAAEC,EAAG,IAAEC,EAAG,IAAEC,GAAQH,EAGpBI,EAAcF,GAAOA,EAAIE,YAAeJ,EAAeI,WAC7D,OAAIA,GAAcA,EAAa,IACtBC,QAAQC,UAUZN,EAAeO,WAIpB,SAAUC,IACJP,GACFO,EAAMC,yBAAyB,CAAEC,QAAST,KAK5C,QAAiBE,GAAO,sCAAsCA,KAAQ,CACpEQ,UAAW,CACTC,KAAM,aACNC,SAAS,EACTC,KAAM,CACJC,SAAU,2CCKpBjB,iBACE,UAEQ,QAAM,KAEZ,MAAOkB,KDFHC,KAvBGZ,QAAQC,U,0BERbY,EAAuB,SAACC,G,OAAsB,SAACC,EAAAA,EAAQ,CAAChB,WAAYe,EAAMf,cAEhFc,EAAqBG,gBAAkB,W,OAAA,iBAAOC,G,iEAG5C,O,EAAMvB,EAAgCuB,I,OAGtC,OAHA,SAGO,C,EAAAC,EAAAA,QAAAA,gBAAmCD,W,gBANEA,G,gCAAP,GASvC,S,gWCtBA,IAAME,EAAiBC,EAAAA,GAAAA,IAAAA,WAAU,C,6BAAVA,C,KA2BvB,IAnBiB,Y,QAAGrB,WAAAA,OAAU,IAAG,MAAG,EAC5B,GAAQsB,EAAAA,EAAAA,MAANC,EAER,OACE,SAACC,EAAAA,EAAI,C,UACH,UAACJ,EAAc,C,WACb,SAACK,EAAAA,EAAQ,CAACC,MAAM,OAAOC,GAAG,SAC1B,SAACC,EAAAA,EAAO,CAACC,MAAM,M,SAAO7B,KACtB,SAAC8B,EAAAA,EAAI,CAACH,GAAG,O,SAAQJ,EAAE,4BACnB,SAACQ,IAAI,CAACC,KAAK,IAAIC,UAAQ,E,UACrB,SAACC,EAAAA,EAAM,CAACC,GAAG,IAAIN,MAAM,K,SAClBN,EAAE,wB,sBCzBfa,EAAOC,QAAU,EAAjB,S","sources":["webpack://_N_E/?222e","webpack://_N_E/./node_modules/@sentry/nextjs/esm/common/_error.js","webpack://_N_E/./node_modules/@sentry/nextjs/esm/common/utils/responseEnd.js","webpack://_N_E/./src/pages/_error.tsx","webpack://_N_E/./src/views/NotFound.tsx","webpack://_N_E/./node_modules/next/error.js"],"sourcesContent":["\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_error\",\n      function () {\n        return require(\"private-next-pages/_error.tsx\");\n      }\n    ]);\n    if(module.hot) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_error\"])\n      });\n    }\n  ","import { withScope, captureException } from '@sentry/core';\nimport { flushQueue } from './utils/responseEnd.js';\n\n/**\n * Capture the exception passed by nextjs to the `_error` page, adding context data as appropriate.\n *\n * @param contextOrProps The data passed to either `getInitialProps` or `render` by nextjs\n */\nasync function captureUnderscoreErrorException(contextOrProps) {\n  const { req, res, err } = contextOrProps;\n\n  // 404s (and other 400-y friends) can trigger `_error`, but we don't want to send them to Sentry\n  const statusCode = (res && res.statusCode) || contextOrProps.statusCode;\n  if (statusCode && statusCode < 500) {\n    return Promise.resolve();\n  }\n\n  // In previous versions of the suggested `_error.js` page in which this function is meant to be used, there was a\n  // workaround for https://github.com/vercel/next.js/issues/8592 which involved an extra call to this function, in the\n  // custom error component's `render` method, just in case it hadn't been called by `getInitialProps`. Now that that\n  // issue has been fixed, the second call is unnecessary, but since it lives in user code rather than our code, users\n  // have to be the ones to get rid of it, and guaraneteedly, not all of them will. So, rather than capture the error\n  // twice, we just bail if we sense we're in that now-extraneous second call. (We can tell which function we're in\n  // because Nextjs passes `pathname` to `getInitialProps` but not to `render`.)\n  if (!contextOrProps.pathname) {\n    return Promise.resolve();\n  }\n\n  withScope(scope => {\n    if (req) {\n      scope.setSDKProcessingMetadata({ request: req });\n    }\n\n    // If third-party libraries (or users themselves) throw something falsy, we want to capture it as a message (which\n    // is what passing a string to `captureException` will wind up doing)\n    captureException(err || `_error.js called with falsy error (${err})`, {\n      mechanism: {\n        type: 'instrument',\n        handled: false,\n        data: {\n          function: '_error.getInitialProps',\n        },\n      },\n    });\n  });\n\n  // In case this is being run as part of a serverless function (as is the case with the server half of nextjs apps\n  // deployed to vercel), make sure the error gets sent to Sentry before the lambda exits.\n  await flushQueue();\n}\n\nexport { captureUnderscoreErrorException };\n//# sourceMappingURL=_error.js.map\n","import { flush, setHttpStatus } from '@sentry/core';\nimport { logger, fill } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\n\n/**\n * Wrap `res.end()` so that it ends the span and flushes events before letting the request finish.\n *\n * Note: This wraps a sync method with an async method. While in general that's not a great idea in terms of keeping\n * things in the right order, in this case it's safe, because the native `.end()` actually *is* (effectively) async, and\n * its run actually *is* (literally) awaited, just manually so (which reflects the fact that the core of the\n * request/response code in Node by far predates the introduction of `async`/`await`). When `.end()` is done, it emits\n * the `prefinish` event, and only once that fires does request processing continue. See\n * https://github.com/nodejs/node/commit/7c9b607048f13741173d397795bac37707405ba7.\n *\n * Also note: `res.end()` isn't called until *after* all response data and headers have been sent, so blocking inside of\n * `end` doesn't delay data getting to the end user. See\n * https://nodejs.org/api/http.html#responseenddata-encoding-callback.\n *\n * @param span The span tracking the request\n * @param res: The request's corresponding response\n */\nfunction autoEndSpanOnResponseEnd(span, res) {\n  const wrapEndMethod = (origEnd) => {\n    return function sentryWrappedEnd( ...args) {\n      finishSpan(span, this);\n      return origEnd.call(this, ...args);\n    };\n  };\n\n  // Prevent double-wrapping\n  // res.end may be undefined during build when using `next export` to statically export a Next.js app\n  if (res.end && !(res.end ).__sentry_original__) {\n    fill(res, 'end', wrapEndMethod);\n  }\n}\n\n/** Finish the given response's span and set HTTP status data */\nfunction finishSpan(span, res) {\n  if (span) {\n    setHttpStatus(span, res.statusCode);\n    span.end();\n  }\n}\n\n/** Flush the event queue to ensure that events get sent to Sentry before the response is finished and the lambda ends */\nasync function flushQueue() {\n  try {\n    DEBUG_BUILD && logger.log('Flushing events...');\n    await flush(2000);\n    DEBUG_BUILD && logger.log('Done flushing events');\n  } catch (e) {\n    DEBUG_BUILD && logger.log('Error while flushing events:\\n', e);\n  }\n}\n\nexport { autoEndSpanOnResponseEnd, finishSpan, flushQueue };\n//# sourceMappingURL=responseEnd.js.map\n","/**\n * This page is loaded by Nextjs:\n *  - on the server, when data-fetching methods throw or reject\n *  - on the client, when `getInitialProps` throws or rejects\n *  - on the client, when a React lifecycle method throws or rejects, and it's\n *    caught by the built-in Nextjs error boundary\n *\n * See:\n *  - https://nextjs.org/docs/basic-features/data-fetching/overview\n *  - https://nextjs.org/docs/api-reference/data-fetching/get-initial-props\n *  - https://reactjs.org/docs/error-boundaries.html\n */\n\nimport { captureUnderscoreErrorException } from '@sentry/nextjs'\nimport NextErrorComponent, { ErrorProps } from 'next/error'\nimport NotFound from '../views/NotFound'\n\nconst CustomErrorComponent = (props: ErrorProps) => <NotFound statusCode={props.statusCode} />\n\nCustomErrorComponent.getInitialProps = async (contextData) => {\n  // In case this is running in a serverless function, await this in order to give Sentry\n  // time to send the error before the lambda exits\n  await captureUnderscoreErrorException(contextData)\n\n  // This will contain the status code of the response\n  return NextErrorComponent.getInitialProps(contextData)\n}\n\nexport default CustomErrorComponent\n","import styled from 'styled-components'\nimport { Button, Heading, Text, LogoIcon } from '@pancakeswap/uikit'\nimport Page from 'components/Layout/Page'\nimport { useTranslation } from 'contexts/Localization'\nimport Link from 'next/link'\n\nconst StyledNotFound = styled.div`\n  align-items: center;\n  display: flex;\n  flex-direction: column;\n  height: calc(100vh - 64px);\n  justify-content: center;\n`\n\nconst NotFound = ({ statusCode = 404 }: { statusCode?: number }) => {\n  const { t } = useTranslation()\n\n  return (\n    <Page>\n      <StyledNotFound>\n        <LogoIcon width=\"64px\" mb=\"8px\" />\n        <Heading scale=\"xxl\">{statusCode}</Heading>\n        <Text mb=\"16px\">{t('Oops, page not found.')}</Text>\n        <Link href=\"/\" passHref>\n          <Button as=\"a\" scale=\"sm\">\n            {t('Back Home')}\n          </Button>\n        </Link>\n      </StyledNotFound>\n    </Page>\n  )\n}\n\nexport default NotFound\n","module.exports = require('./dist/pages/_error')\n"],"names":["window","__NEXT_P","push","async","captureUnderscoreErrorException","contextOrProps","req","res","err","statusCode","Promise","resolve","pathname","scope","setSDKProcessingMetadata","request","mechanism","type","handled","data","function","e","flushQueue","CustomErrorComponent","props","NotFound","getInitialProps","contextData","NextErrorComponent","StyledNotFound","styled","useTranslation","t","Page","LogoIcon","width","mb","Heading","scale","Text","Link","href","passHref","Button","as","module","exports"],"sourceRoot":""}