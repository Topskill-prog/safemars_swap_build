{"version":3,"file":"static/chunks/3789-6fcdfeb8c2e511d8.js","mappings":"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","sources":["webpack://_N_E/./packages/uikit/src/components/Svg/Icons/Binance.tsx","webpack://_N_E/./packages/uikit/src/components/Svg/Icons/ChevronDown.tsx","webpack://_N_E/./packages/utils/tryParseAmount.ts","webpack://_N_E/./packages/utils/uriToHttp.ts","webpack://_N_E/./src/utils/getTokenLogoURL.ts","webpack://_N_E/./src/components/Logo/CurrencyLogo.tsx","webpack://_N_E/./src/components/Logo/Logo.tsx","webpack://_N_E/./src/components/Logo/DoubleLogo.tsx","webpack://_N_E/./src/components/Logo/ListLogo.tsx","webpack://_N_E/./src/utils/trades.ts","webpack://_N_E/./src/hooks/Trades.ts","webpack://_N_E/./src/hooks/useHttpLocations.ts","webpack://_N_E/./src/state/swap/queries/lastPairDayId.ts","webpack://_N_E/./src/state/swap/queries/pairHourDatas.ts","webpack://_N_E/./src/state/swap/queries/pairDayDatasByIdsQuery.ts","webpack://_N_E/./src/state/swap/fetch/constants.ts","webpack://_N_E/./src/state/swap/fetch/utils.ts","webpack://_N_E/./src/state/swap/queries/pairDayDatas.ts","webpack://_N_E/./src/state/swap/queries/pairHourDatasByIds.ts","webpack://_N_E/./src/state/swap/queries/lastPairHourId.ts","webpack://_N_E/./src/state/swap/fetch/fetchPairPriceData.ts","webpack://_N_E/./src/state/swap/queries/getDerivedPrices.ts","webpack://_N_E/./src/state/swap/fetch/fetchDerivedPriceData.ts","webpack://_N_E/./src/state/swap/hooks.ts","webpack://_N_E/./src/state/swap/selectors.ts","webpack://_N_E/./src/state/swap/normalizers.ts","webpack://_N_E/./src/state/swap/types.ts","webpack://_N_E/./src/utils/currencyId.ts","webpack://_N_E/./src/utils/exchange.ts","webpack://_N_E/./src/views/Swap/components/Chart/constants.ts","webpack://_N_E/./src/views/Swap/components/Chart/utils.ts"],"sourcesContent":["import _object_spread from \"@swc/helpers/src/_object_spread.mjs\";\nimport _object_spread_props from \"@swc/helpers/src/_object_spread_props.mjs\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport React from \"react\";\nimport Svg from \"../Svg\";\nvar Icon = function(props) {\n    return /*#__PURE__*/ _jsx(Svg, _object_spread_props(_object_spread({\n        viewBox: \"0 0 48 48\"\n    }, props), {\n        children: /*#__PURE__*/ _jsx(\"image\", {\n            href: \"/images/tokens/somi.png\",\n            width: 48,\n            height: 48\n        })\n    }));\n};\nexport default Icon;\n","import _object_spread from \"@swc/helpers/src/_object_spread.mjs\";\nimport _object_spread_props from \"@swc/helpers/src/_object_spread_props.mjs\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport React from \"react\";\nimport Svg from \"../Svg\";\nvar Icon = function(props) {\n    return /*#__PURE__*/ _jsx(Svg, _object_spread_props(_object_spread({\n        viewBox: \"0 0 24 24\"\n    }, props), {\n        children: /*#__PURE__*/ _jsx(\"path\", {\n            d: \"M8.11997 9.29006L12 13.1701L15.88 9.29006C16.27 8.90006 16.9 8.90006 17.29 9.29006C17.68 9.68006 17.68 10.3101 17.29 10.7001L12.7 15.2901C12.31 15.6801 11.68 15.6801 11.29 15.2901L6.69997 10.7001C6.30997 10.3101 6.30997 9.68006 6.69997 9.29006C7.08997 8.91006 7.72997 8.90006 8.11997 9.29006Z\"\n        })\n    }));\n};\nexport default Icon;\n","import { parseUnits } from '@ethersproject/units'\nimport { Currency, CurrencyAmount, JSBI } from '@pancakeswap/sdk'\n\n// try to parse a user entered amount for a given token\nfunction tryParseAmount<T extends Currency>(value?: string, currency?: T): CurrencyAmount<T> | undefined {\n  if (!value || !currency) {\n    return undefined\n  }\n  try {\n    const typedValueParsed = parseUnits(value, currency.decimals).toString()\n\n    if (typedValueParsed !== '0') {\n      return CurrencyAmount.fromRawAmount(currency, JSBI.BigInt(typedValueParsed))\n    }\n  } catch (error) {\n    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    console.debug(`Failed to parse input amount: \"${value}\"`, error)\n  }\n  // necessary for all paths to return a value\n  return undefined\n}\n\nexport default tryParseAmount\n","/* eslint-disable no-case-declarations */\n/**\n * Given a URI that may be ipfs, ipns, http, or https protocol, return the fetch-able http(s) URLs for the same content\n * @param uri to convert to fetch-able http url\n */\nexport default function uriToHttp(uri: string): string[] {\n  const protocol = uri.split(':')[0].toLowerCase()\n  switch (protocol) {\n    case 'https':\n      return [uri]\n    case 'http':\n      return [`https${uri.substring(4)}`, uri]\n    case 'ipfs':\n      const hash = uri.match(/^ipfs:(\\/\\/)?(.*)$/i)?.[2]\n      return [`https://cloudflare-ipfs.com/ipfs/${hash}/`, `https://ipfs.io/ipfs/${hash}/`]\n    case 'ipns':\n      const name = uri.match(/^ipns:(\\/\\/)?(.*)$/i)?.[2]\n      return [`https://cloudflare-ipfs.com/ipns/${name}/`, `https://ipfs.io/ipns/${name}/`]\n    default:\n      return []\n  }\n}\n","import { ChainId, Token } from '@pancakeswap/sdk'\n\nconst mapping = {\n  [ChainId.PULSE_CHAIN]: 'smartchain',\n  [ChainId.ETHEREUM]: 'ethereum',\n  // [ChainId.EGOLD]: 'egold',\n  [ChainId.SOMNIA]: 'somnia',\n  [ChainId.ARBITRUM]: 'arbitrum',\n  [ChainId.BSC]: 'bsc',\n  [ChainId.POLYGON]: 'polygon',\n}\n\nconst getTokenLogoURL = (token?: Token) => {\n  if (token && mapping[token.chainId]) {\n    return `/images/tokens/${token.address}.png`\n    // return `images/${mapping[token.chainId]}/assets/${token.address}/safemars.png`\n  }\n  return null\n}\n\nexport default getTokenLogoURL\n","import { ChainId, Currency } from '@pancakeswap/sdk'\nimport { BinanceIcon } from '@pancakeswap/uikit'\nimport { useMemo } from 'react'\nimport { WrappedTokenInfo } from '@pancakeswap/tokens'\nimport styled from 'styled-components'\nimport useHttpLocations from '../../hooks/useHttpLocations'\nimport getTokenLogoURL from '../../utils/getTokenLogoURL'\nimport Logo from './Logo'\n\nconst StyledLogo = styled(Logo)<{ size: string }>`\n  width: ${({ size }) => size};\n  height: ${({ size }) => size};\n  border-radius: 50%;\n`\n\nexport default function CurrencyLogo({\n  currency,\n  size = '24px',\n  style,\n}: {\n  currency?: Currency\n  size?: string\n  style?: React.CSSProperties\n}) {\n  const uriLocations = useHttpLocations(currency instanceof WrappedTokenInfo ? currency.logoURI : undefined)\n\n  const srcs: string[] = useMemo(() => {\n    if (currency?.isNative) return []\n\n    if (currency?.isToken) {\n      const tokenLogoURL = getTokenLogoURL(currency)\n\n      if (currency instanceof WrappedTokenInfo) {\n        if (!tokenLogoURL) return [...uriLocations]\n        return [...uriLocations, tokenLogoURL]\n      }\n      if (!tokenLogoURL) return []\n      return [tokenLogoURL]\n    }\n    return []\n  }, [currency, uriLocations])\n\n  if (currency?.isNative) {\n    if (currency.chainId === ChainId.SOMNIA) {\n      return <BinanceIcon width={size} style={style} />\n    }\n    return <StyledLogo size={size} srcs={[`/images/chains/${currency.chainId}.png`]} width={size} style={style} />\n  }\n\n  return <StyledLogo size={size} srcs={srcs} alt={`${currency?.symbol ?? 'token'} logo`} style={style} />\n}\n","import { useState } from 'react'\nimport { HelpIcon } from '@pancakeswap/uikit'\n\nexport const BAD_SRCS: { [imageSrc: string]: true } = {}\n\nexport interface LogoProps extends React.ImgHTMLAttributes<HTMLImageElement> {\n  srcs: string[]\n}\n\n/**\n * Renders an image by sequentially trying a list of URIs, and then eventually a fallback triangle alert\n */\nconst Logo: React.FC<React.PropsWithChildren<LogoProps>> = ({ srcs, alt, ...rest }) => {\n  const [, refresh] = useState<number>(0)\n\n  const src: string | undefined = srcs.find((s) => !BAD_SRCS[s])\n\n  if (src) {\n    return (\n      <img\n        {...rest}\n        alt={alt}\n        src={src}\n        onError={() => {\n          if (src) BAD_SRCS[src] = true\n          refresh((i) => i + 1)\n        }}\n      />\n    )\n  }\n\n  return <HelpIcon {...rest} />\n}\n\nexport default Logo\n","import { Currency } from '@pancakeswap/sdk'\nimport styled from 'styled-components'\nimport CurrencyLogo from './CurrencyLogo'\n\nconst Wrapper = styled.div<{ margin: boolean }>`\n  display: flex;\n  flex-direction: row;\n  margin-right: ${({ margin }) => margin && '4px'};\n`\n\ninterface DoubleCurrencyLogoProps {\n  margin?: boolean\n  size?: number\n  currency0?: Currency\n  currency1?: Currency\n}\n\nexport default function DoubleCurrencyLogo({\n  currency0,\n  currency1,\n  size = 20,\n  margin = false,\n}: DoubleCurrencyLogoProps) {\n  return (\n    <Wrapper margin={margin}>\n      {currency0 && <CurrencyLogo currency={currency0} size={`${size.toString()}px`} style={{ marginRight: '4px' }} />}\n      {currency1 && <CurrencyLogo currency={currency1} size={`${size.toString()}px`} />}\n    </Wrapper>\n  )\n}\n","import styled from 'styled-components'\nimport useHttpLocations from '../../hooks/useHttpLocations'\nimport Logo from './Logo'\n\nconst StyledListLogo = styled(Logo)<{ size: string }>`\n  width: ${({ size }) => size};\n  height: ${({ size }) => size};\n`\n\nexport default function ListLogo({\n  logoURI,\n  style,\n  size = '24px',\n  alt,\n}: {\n  logoURI: string\n  size?: string\n  style?: React.CSSProperties\n  alt?: string\n}) {\n  const srcs: string[] = useHttpLocations(logoURI)\n\n  return <StyledListLogo alt={alt} size={size} srcs={srcs} style={style} />\n}\n","import { Trade, Percent, Currency, TradeType } from '@pancakeswap/sdk'\nimport { ZERO_PERCENT, ONE_HUNDRED_PERCENT } from 'config/constants/exchange'\n\n// returns whether tradeB is better than tradeA by at least a threshold percentage amount\nexport function isTradeBetter(\n  tradeA: Trade<Currency, Currency, TradeType> | undefined | null,\n  tradeB: Trade<Currency, Currency, TradeType> | undefined | null,\n  minimumDelta: Percent = ZERO_PERCENT,\n): boolean | undefined {\n  if (tradeA && !tradeB) return false\n  if (tradeB && !tradeA) return true\n  if (!tradeA || !tradeB) return undefined\n\n  if (\n    tradeA.tradeType !== tradeB.tradeType ||\n    !tradeA.inputAmount.currency.equals(tradeB.inputAmount.currency) ||\n    !tradeA.outputAmount.currency.equals(tradeB.outputAmount.currency)\n  ) {\n    throw new Error('Trades are not comparable')\n  }\n\n  if (minimumDelta.equalTo(ZERO_PERCENT)) {\n    return tradeA.executionPrice.lessThan(tradeB.executionPrice)\n  }\n  return tradeA.executionPrice.asFraction\n    .multiply(minimumDelta.add(ONE_HUNDRED_PERCENT))\n    .lessThan(tradeB.executionPrice)\n}\n\nexport default isTradeBetter\n","/* eslint-disable no-param-reassign */\nimport { isTradeBetter } from 'utils/trades'\nimport { Currency, CurrencyAmount, Pair, Token, Trade, TradeType } from '@pancakeswap/sdk'\nimport flatMap from 'lodash/flatMap'\nimport { useMemo } from 'react'\nimport useActiveWeb3React from 'hooks/useActiveWeb3React'\n\nimport { useUserSingleHopOnly } from 'state/user/hooks'\nimport {\n  BASES_TO_CHECK_TRADES_AGAINST,\n  CUSTOM_BASES,\n  BETTER_TRADE_LESS_HOPS_THRESHOLD,\n  ADDITIONAL_BASES,\n} from 'config/constants/exchange'\nimport { PairState, usePairs } from './usePairs'\nimport { wrappedCurrency } from '../utils/wrappedCurrency'\n\nimport { useUnsupportedTokens, useWarningTokens } from './Tokens'\n\nexport function useAllCommonPairs(currencyA?: Currency, currencyB?: Currency): Pair[] {\n  const { chainId } = useActiveWeb3React()\n\n  const [tokenA, tokenB] = chainId\n    ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]\n    : [undefined, undefined]\n\n  const bases: Token[] = useMemo(() => {\n    if (!chainId) return []\n\n    const common = BASES_TO_CHECK_TRADES_AGAINST[chainId] ?? []\n    const additionalA = tokenA ? ADDITIONAL_BASES[chainId]?.[tokenA.address] ?? [] : []\n    const additionalB = tokenB ? ADDITIONAL_BASES[chainId]?.[tokenB.address] ?? [] : []\n\n    return [...common, ...additionalA, ...additionalB]\n  }, [chainId, tokenA, tokenB])\n\n  const basePairs: [Token, Token][] = useMemo(\n    () => flatMap(bases, (base): [Token, Token][] => bases.map((otherBase) => [base, otherBase])),\n    [bases],\n  )\n\n  const allPairCombinations: [Token, Token][] = useMemo(\n    () =>\n      tokenA && tokenB\n        ? [\n            // the direct pair\n            [tokenA, tokenB],\n            // token A against all bases\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\n            // token B against all bases\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\n            // each base against all bases\n            ...basePairs,\n          ]\n            .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\n            .filter(([t0, t1]) => t0.address !== t1.address)\n            .filter(([tokenA_, tokenB_]) => {\n              if (!chainId) return true\n              const customBases = CUSTOM_BASES[chainId]\n\n              const customBasesA: Token[] | undefined = customBases?.[tokenA_.address]\n              const customBasesB: Token[] | undefined = customBases?.[tokenB_.address]\n\n              if (!customBasesA && !customBasesB) return true\n\n              if (customBasesA && !customBasesA.find((base) => tokenB_.equals(base))) return false\n              if (customBasesB && !customBasesB.find((base) => tokenA_.equals(base))) return false\n\n              return true\n            })\n        : [],\n    [tokenA, tokenB, bases, basePairs, chainId],\n  )\n\n  const allPairs = usePairs(allPairCombinations)\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(\n    () =>\n      Object.values(\n        allPairs\n          // filter out invalid pairs\n          .filter((result): result is [PairState.EXISTS, Pair] => Boolean(result[0] === PairState.EXISTS && result[1]))\n          // filter out duplicated pairs\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\n            memo[curr.liquidityToken.address] = memo[curr.liquidityToken.address] ?? curr\n            return memo\n          }, {}),\n      ),\n    [allPairs],\n  )\n}\n\nconst MAX_HOPS = 3\n\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\nexport function useTradeExactIn(\n  currencyAmountIn?: CurrencyAmount<Currency>,\n  currencyOut?: Currency,\n): Trade<Currency, Currency, TradeType> | null {\n  const allowedPairs = useAllCommonPairs(currencyAmountIn?.currency, currencyOut)\n\n  const [singleHopOnly] = useUserSingleHopOnly()\n\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        return (\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: 1, maxNumResults: 1 })[0] ??\n          null\n        )\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar: Trade<Currency, Currency, TradeType> | null = null\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        const currentTrade: Trade<Currency, Currency, TradeType> | null =\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: i, maxNumResults: 1 })[0] ??\n          null\n        // if current trade is best yet, save it\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade\n        }\n      }\n      return bestTradeSoFar\n    }\n\n    return null\n  }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly])\n}\n\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\nexport function useTradeExactOut(\n  currencyIn?: Currency,\n  currencyAmountOut?: CurrencyAmount<Currency>,\n): Trade<Currency, Currency, TradeType> | null {\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut?.currency)\n\n  const [singleHopOnly] = useUserSingleHopOnly()\n\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        return (\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: 1, maxNumResults: 1 })[0] ??\n          null\n        )\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar: Trade<Currency, Currency, TradeType> | null = null\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        const currentTrade =\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: i, maxNumResults: 1 })[0] ??\n          null\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade\n        }\n      }\n      return bestTradeSoFar\n    }\n    return null\n  }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly])\n}\n\nexport function useIsTransactionUnsupported(currencyIn?: Currency, currencyOut?: Currency): boolean {\n  const unsupportedTokens: { [address: string]: Token } = useUnsupportedTokens()\n  const { chainId } = useActiveWeb3React()\n\n  const tokenIn = wrappedCurrency(currencyIn, chainId)\n  const tokenOut = wrappedCurrency(currencyOut, chainId)\n\n  // if unsupported list loaded & either token on list, mark as unsupported\n  if (unsupportedTokens) {\n    if (tokenIn && Object.keys(unsupportedTokens).includes(tokenIn.address)) {\n      return true\n    }\n    if (tokenOut && Object.keys(unsupportedTokens).includes(tokenOut.address)) {\n      return true\n    }\n  }\n\n  return false\n}\n\nexport function useIsTransactionWarning(currencyIn?: Currency, currencyOut?: Currency): boolean {\n  const unsupportedTokens: { [address: string]: Token } = useWarningTokens()\n  const { chainId } = useActiveWeb3React()\n\n  const tokenIn = wrappedCurrency(currencyIn, chainId)\n  const tokenOut = wrappedCurrency(currencyOut, chainId)\n\n  // if unsupported list loaded & either token on list, mark as unsupported\n  if (unsupportedTokens) {\n    if (tokenIn && Object.keys(unsupportedTokens).includes(tokenIn.address)) {\n      return true\n    }\n    if (tokenOut && Object.keys(unsupportedTokens).includes(tokenOut.address)) {\n      return true\n    }\n  }\n\n  return false\n}\n","import { useMemo } from 'react'\nimport uriToHttp from '@pancakeswap/utils/uriToHttp'\n\nexport default function useHttpLocations(uri: string | undefined): string[] {\n  return useMemo(() => {\n    return uri ? uriToHttp(uri) : []\n  }, [uri])\n}\n","import { gql } from 'graphql-request'\n\nconst lastPairDayId = gql`\n  query lastPairDayId($pairId: String) {\n    pairDayDatas(first: 1, where: { pairAddress: $pairId }, orderBy: date, orderDirection: desc) {\n      id\n    }\n  }\n`\nexport default lastPairDayId\n","import { gql } from 'graphql-request'\n\nconst pairHourDatas = gql`\n  query pairHourDatas($pairId: String, $first: Int) {\n    pairHourDatas(first: $first, where: { pair: $pairId }, orderBy: hourStartUnix, orderDirection: desc) {\n      id\n      hourStartUnix\n      reserve0\n      reserve1\n      reserveUSD\n      pair {\n        token0 {\n          id\n        }\n        token1 {\n          id\n        }\n      }\n    }\n  }\n`\nexport default pairHourDatas\n","import { gql } from 'graphql-request'\n\nconst pairDayDatasByIdsQuery = gql`\n  query pairDayDatasByIdsQuery($pairIds: [String]) {\n    pairDayDatas(where: { id_in: $pairIds }, orderBy: date, orderDirection: desc) {\n      id\n      date\n      reserve0\n      reserve1\n      reserveUSD\n      pairAddress {\n        token0 {\n          id\n        }\n        token1 {\n          id\n        }\n      }\n    }\n  }\n`\nexport default pairDayDatasByIdsQuery\n","import { PairDataTimeWindowEnum } from '../types'\n\n// Specifies the amount of data points to query for specific time window\nexport const timeWindowIdsCountMapping: Record<PairDataTimeWindowEnum, number> = {\n  [PairDataTimeWindowEnum.DAY]: 24,\n  [PairDataTimeWindowEnum.WEEK]: 28,\n  [PairDataTimeWindowEnum.MONTH]: 30,\n  [PairDataTimeWindowEnum.YEAR]: 24,\n}\n\n// How many StreamingFast ids to skip when querying the data\nexport const timeWindowGapMapping: Record<PairDataTimeWindowEnum, number | null> = {\n  [PairDataTimeWindowEnum.DAY]: null,\n  [PairDataTimeWindowEnum.WEEK]: 6, // Each datapoint 6 hours apart\n  [PairDataTimeWindowEnum.MONTH]: 1, // Each datapoint 1 day apart\n  [PairDataTimeWindowEnum.YEAR]: 15, // Each datapoint 15 days apart\n}\n","import times from 'lodash/times'\nimport { PairDataTimeWindowEnum } from '../types'\nimport { timeWindowGapMapping } from './constants'\nimport { PairDayDatasResponse, PairHoursDatasResponse } from './types'\n\ntype getPairSequentialIdParams = {\n  id: string\n  pairId: string\n}\nexport const getPairSequentialId = ({ id, pairId }: getPairSequentialIdParams) => id.replace(`${pairId}-`, '')\n\ntype getPairHoursIdsByTimeWindowParams = {\n  pairAddress: string\n  pairLastId: string\n  timeWindow: PairDataTimeWindowEnum\n  idsCount: number\n}\n\nexport const getIdsByTimeWindow = ({\n  pairAddress,\n  pairLastId,\n  timeWindow,\n  idsCount,\n}: getPairHoursIdsByTimeWindowParams) => {\n  const pairLastIdAsNumber = Number(pairLastId)\n  if (timeWindow === PairDataTimeWindowEnum.DAY) {\n    return []\n  }\n  return times(idsCount, (value) => `${pairAddress}-${pairLastIdAsNumber - value * timeWindowGapMapping[timeWindow]}`)\n}\n\nexport const pairHasEnoughLiquidity = (\n  data: PairHoursDatasResponse | PairDayDatasResponse | null,\n  timeWindow: PairDataTimeWindowEnum,\n) => {\n  const liquidityThreshold = 10000\n  switch (timeWindow) {\n    case PairDataTimeWindowEnum.DAY:\n    case PairDataTimeWindowEnum.WEEK: {\n      const amountOfDataPoints = (data as PairHoursDatasResponse)?.pairHourDatas?.length ?? 1\n      const totalUSD = (data as PairHoursDatasResponse)?.pairHourDatas?.reduce((totalLiquidity, fetchPairEntry) => {\n        return totalLiquidity + parseFloat(fetchPairEntry.reserveUSD)\n      }, 0)\n      return totalUSD / amountOfDataPoints > liquidityThreshold\n    }\n    case PairDataTimeWindowEnum.MONTH:\n    case PairDataTimeWindowEnum.YEAR: {\n      const amountOfDataPoints = (data as PairDayDatasResponse)?.pairDayDatas?.length ?? 1\n      const totalUSD = (data as PairDayDatasResponse)?.pairDayDatas?.reduce((totalLiquidity, fetchPairEntry) => {\n        return totalLiquidity + parseFloat(fetchPairEntry.reserveUSD)\n      }, 0)\n      return totalUSD / amountOfDataPoints > liquidityThreshold\n    }\n    default:\n      return null\n  }\n}\n","import { gql } from 'graphql-request'\n\nconst pairDayDatas = gql`\n  query pairDayDatas($pairId: String, $first: Int) {\n    pairDayDatas(first: $first, where: { pairAddress: $pairId }, orderBy: date, orderDirection: desc) {\n      id\n      date\n      reserve0\n      reserve1\n      reserveUSD\n      pairAddress {\n        token0 {\n          id\n        }\n        token1 {\n          id\n        }\n      }\n    }\n  }\n`\nexport default pairDayDatas\n","import { gql } from 'graphql-request'\n\nconst pairHourDatasByIds = gql`\n  query pairHourDatasByIds($pairIds: [String]) {\n    pairHourDatas(where: { id_in: $pairIds }, orderBy: hourStartUnix, orderDirection: desc) {\n      id\n      hourStartUnix\n      reserve0\n      reserve1\n      reserveUSD\n      pair {\n        token0 {\n          id\n        }\n        token1 {\n          id\n        }\n      }\n    }\n  }\n`\nexport default pairHourDatasByIds\n","import { gql } from 'graphql-request'\n\nconst lastPairHourId = gql`\n  query lastPairHourId($pairId: String) {\n    pairHourDatas(first: 1, where: { pair: $pairId }, orderBy: hourStartUnix, orderDirection: desc) {\n      id\n    }\n  }\n`\nexport default lastPairHourId\n","import requestWithTimeout from 'utils/requestWithTimeout'\nimport { infoClient } from 'utils/graphql'\nimport lastPairDayId from '../queries/lastPairDayId'\nimport pairHourDatas from '../queries/pairHourDatas'\nimport pairDayDatasByIdsQuery from '../queries/pairDayDatasByIdsQuery'\nimport { PairDataTimeWindowEnum } from '../types'\nimport { timeWindowIdsCountMapping } from './constants'\nimport {\n  fetchPairDataParams,\n  LastPairDayIdResponse,\n  LastPairHourIdResponse,\n  PairDayDatasResponse,\n  PairHoursDatasResponse,\n} from './types'\nimport { getIdsByTimeWindow, getPairSequentialId } from './utils'\nimport pairDayDatas from '../queries/pairDayDatas'\nimport pairHourDatasByIds from '../queries/pairHourDatasByIds'\nimport lastPairHourId from '../queries/lastPairHourId'\n\nconst fetchPairPriceData = async ({ pairId, timeWindow }: fetchPairDataParams) => {\n  const client = infoClient\n\n  try {\n    switch (timeWindow) {\n      case PairDataTimeWindowEnum.DAY: {\n        const data = await requestWithTimeout<PairHoursDatasResponse>(client, pairHourDatas, {\n          pairId,\n          first: timeWindowIdsCountMapping[timeWindow],\n        })\n        return { data, error: false }\n      }\n      case PairDataTimeWindowEnum.WEEK: {\n        const lastPairHourIdData = await requestWithTimeout<LastPairHourIdResponse>(client, lastPairHourId, { pairId })\n        const lastId = lastPairHourIdData?.pairHourDatas ? lastPairHourIdData.pairHourDatas[0]?.id : null\n        if (!lastId) {\n          return { data: { pairHourDatas: [] }, error: false }\n        }\n        const pairHourId = getPairSequentialId({ id: lastId, pairId })\n        const pairHourIds = getIdsByTimeWindow({\n          pairAddress: pairId,\n          pairLastId: pairHourId,\n          timeWindow,\n          idsCount: timeWindowIdsCountMapping[timeWindow],\n        })\n\n        const pairHoursData = await requestWithTimeout<PairHoursDatasResponse>(client, pairHourDatasByIds, {\n          pairIds: pairHourIds,\n        })\n        return { data: pairHoursData, error: false }\n      }\n      case PairDataTimeWindowEnum.MONTH: {\n        const data = await requestWithTimeout<PairHoursDatasResponse>(client, pairDayDatas, {\n          pairId,\n          first: timeWindowIdsCountMapping[timeWindow],\n        })\n        return { data, error: false }\n      }\n      case PairDataTimeWindowEnum.YEAR: {\n        const lastPairDayIdData = await requestWithTimeout<LastPairDayIdResponse>(client, lastPairDayId, { pairId })\n        const lastId = lastPairDayIdData?.pairDayDatas ? lastPairDayIdData.pairDayDatas[0]?.id : null\n        if (!lastId) {\n          return { data: { pairDayDatas: [] }, error: false }\n        }\n        const pairLastId = getPairSequentialId({ id: lastId, pairId })\n        const pairDayIds = getIdsByTimeWindow({\n          pairAddress: pairId,\n          pairLastId,\n          timeWindow,\n          idsCount: timeWindowIdsCountMapping[timeWindow],\n        })\n        const pairDayData = await requestWithTimeout<PairDayDatasResponse>(client, pairDayDatasByIdsQuery, {\n          pairIds: pairDayIds,\n        })\n        return { data: pairDayData, error: false }\n      }\n      default:\n        return { data: null, error: false }\n    }\n  } catch (error) {\n    console.error('Failed to fetch price chart data', error)\n    return { error: true }\n  }\n}\n\nexport default fetchPairPriceData\n","import { gql } from 'graphql-request'\nimport { Block } from 'state/info/types'\n\nexport const getDerivedPrices = (tokenAddress: string, blocks: Block[]) =>\n  blocks.map(\n    (block) => `\n    t${block.timestamp}:token(id:\"${tokenAddress}\", block: { number: ${block.number} }) { \n        derivedETH\n      }\n    `,\n  )\n\nexport const getDerivedPricesQueryConstructor = (subqueries: string[]) => {\n  return gql`\n      query derivedTokenPriceData {\n        ${subqueries}\n      }\n    `\n}\n","import orderBy from 'lodash/orderBy'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\nimport { ONE_DAY_UNIX, ONE_HOUR_SECONDS } from 'config/constants/info'\nimport { getBlocksFromTimestamps } from 'utils/getBlocksFromTimestamps'\nimport { getUnixTime, startOfHour, sub } from 'date-fns'\nimport { Block } from 'state/info/types'\nimport { multiQuery } from 'views/Info/utils/infoQueryHelpers'\nimport { getDerivedPrices, getDerivedPricesQueryConstructor } from '../queries/getDerivedPrices'\nimport { PairDataTimeWindowEnum } from '../types'\n\nconst getTokenDerivedBnbPrices = async (tokenAddress: string, blocks: Block[]) => {\n  const prices: any | undefined = await multiQuery(\n    getDerivedPricesQueryConstructor,\n    getDerivedPrices(tokenAddress, blocks),\n    INFO_CLIENT,\n    200,\n  )\n\n  if (!prices) {\n    console.error('Price data failed to load')\n    return null\n  }\n\n  // format token BNB price results\n  const tokenPrices: {\n    tokenAddress: string\n    timestamp: string\n    derivedETH: number\n  }[] = []\n\n  // Get Token prices in BNB\n  Object.keys(prices).forEach((priceKey) => {\n    const timestamp = priceKey.split('t')[1]\n    if (timestamp) {\n      tokenPrices.push({\n        tokenAddress,\n        timestamp,\n        derivedETH: prices[priceKey]?.derivedETH ? parseFloat(prices[priceKey].derivedETH) : 0,\n      })\n    }\n  })\n\n  return orderBy(tokenPrices, (tokenPrice) => parseInt(tokenPrice.timestamp, 10))\n}\n\nconst getInterval = (timeWindow: PairDataTimeWindowEnum) => {\n  switch (timeWindow) {\n    case PairDataTimeWindowEnum.DAY:\n      return ONE_HOUR_SECONDS\n    case PairDataTimeWindowEnum.WEEK:\n      return ONE_HOUR_SECONDS * 4\n    case PairDataTimeWindowEnum.MONTH:\n      return ONE_DAY_UNIX\n    case PairDataTimeWindowEnum.YEAR:\n      return ONE_DAY_UNIX * 15\n    default:\n      return ONE_HOUR_SECONDS * 4\n  }\n}\n\nconst getSkipDaysToStart = (timeWindow: PairDataTimeWindowEnum) => {\n  switch (timeWindow) {\n    case PairDataTimeWindowEnum.DAY:\n      return 1\n    case PairDataTimeWindowEnum.WEEK:\n      return 7\n    case PairDataTimeWindowEnum.MONTH:\n      return 30\n    case PairDataTimeWindowEnum.YEAR:\n      return 365\n    default:\n      return 7\n  }\n}\n\n// Fetches derivedBnb values for tokens to calculate derived price\n// Used when no direct pool is available\nconst fetchDerivedPriceData = async (\n  token0Address: string,\n  token1Address: string,\n  timeWindow: PairDataTimeWindowEnum,\n) => {\n  const interval = getInterval(timeWindow)\n  const endTimestamp = getUnixTime(new Date())\n  const startTimestamp = getUnixTime(startOfHour(sub(endTimestamp * 1000, { days: getSkipDaysToStart(timeWindow) })))\n  const timestamps = []\n  let time = startTimestamp\n  while (time <= endTimestamp) {\n    timestamps.push(time)\n    time += interval\n  }\n\n  try {\n    const blocks = await getBlocksFromTimestamps(timestamps, 'asc', 500)\n    if (!blocks || blocks.length === 0) {\n      console.error('Error fetching blocks for timestamps', timestamps)\n      return null\n    }\n\n    const [token0DerivedBnb, token1DerivedBnb] = await Promise.all([\n      getTokenDerivedBnbPrices(token0Address, blocks),\n      getTokenDerivedBnbPrices(token1Address, blocks),\n    ])\n    return { token0DerivedBnb, token1DerivedBnb }\n  } catch (error) {\n    console.error('Failed to fetched derived price data for chart', error)\n    return null\n  }\n}\n\nexport default fetchDerivedPriceData\n","import { useWeb3React } from '@pancakeswap/wagmi'\nimport { ChainId, Currency, CurrencyAmount, Pair, Trade, TradeType } from '@pancakeswap/sdk'\nimport { ParsedUrlQuery } from 'querystring'\nimport { useEffect, useMemo, useState } from 'react'\nimport { SLOW_INTERVAL } from 'config/constants'\nimport { DEFAULT_INPUT_CURRENCY, DEFAULT_OUTPUT_CURRENCY } from 'config/constants/exchange'\nimport useSWRImmutable from 'swr/immutable'\nimport { useDispatch, useSelector } from 'react-redux'\nimport useActiveWeb3React from 'hooks/useActiveWeb3React'\nimport { useTradeExactIn, useTradeExactOut } from 'hooks/Trades'\nimport { useRouter } from 'next/router'\nimport { useTranslation } from 'contexts/Localization'\nimport { isAddress } from 'utils'\nimport { getDeltaTimestamps } from 'utils/getDeltaTimestamps'\nimport { getBlocksFromTimestamps } from 'utils/getBlocksFromTimestamps'\nimport { getChangeForPeriod } from 'utils/getChangeForPeriod'\nimport { getLpFeesAndApr } from 'utils/getLpFeesAndApr'\nimport useNativeCurrency from 'hooks/useNativeCurrency'\nimport { computeSlippageAdjustedAmounts } from 'utils/exchange'\nimport { CAKE, USDC } from '@pancakeswap/tokens'\nimport getLpAddress from 'utils/getLpAddress'\nimport { getTokenAddress } from 'views/Swap/components/Chart/utils'\nimport tryParseAmount from '@pancakeswap/utils/tryParseAmount'\nimport { AppState, useAppDispatch } from '../index'\nimport { useCurrencyBalances } from '../wallet/hooks'\nimport { Field, replaceSwapState, updateDerivedPairData, updatePairData } from './actions'\nimport { SwapState } from './reducer'\nimport { useUserSlippageTolerance } from '../user/hooks'\nimport fetchPairPriceData from './fetch/fetchPairPriceData'\nimport {\n  normalizeChartData,\n  normalizeDerivedChartData,\n  normalizeDerivedPairDataByActiveToken,\n  normalizePairDataByActiveToken,\n} from './normalizers'\nimport { PairDataTimeWindowEnum } from './types'\nimport { derivedPairByDataIdSelector, pairByDataIdSelector } from './selectors'\nimport fetchDerivedPriceData from './fetch/fetchDerivedPriceData'\nimport { pairHasEnoughLiquidity } from './fetch/utils'\nimport { parsePoolData, fetchPoolData, FormattedPoolFields } from '../info/queries/pools/poolData'\n\nexport function useSwapState(): AppState['swap'] {\n  return useSelector<AppState, AppState['swap']>((state) => state.swap)\n}\n\n// TODO: update\nconst BAD_RECIPIENT_ADDRESSES: string[] = [\n  '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f', // v2 factory\n  '0xf164fC0Ec4E93095b804a4795bBe1e041497b92a', // v2 router 01\n  '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D', // v2 router 02\n]\n\n/**\n * Returns true if any of the pairs or tokens in a trade have the given checksummed address\n * @param trade to check for the given address\n * @param checksummedAddress address to check in the pairs and tokens\n */\nfunction involvesAddress(trade: Trade<Currency, Currency, TradeType>, checksummedAddress: string): boolean {\n  return (\n    trade.route.path.some((token) => token.address === checksummedAddress) ||\n    trade.route.pairs.some((pair) => pair.liquidityToken.address === checksummedAddress)\n  )\n}\n\n// Get swap price for single token disregarding slippage and price impact\nexport function useSingleTokenSwapInfo(\n  inputCurrencyId: string | undefined,\n  inputCurrency: Currency | undefined,\n  outputCurrencyId: string | undefined,\n  outputCurrency: Currency | undefined,\n): { [key: string]: number } {\n  const token0Address = getTokenAddress(inputCurrencyId)\n  const token1Address = getTokenAddress(outputCurrencyId)\n\n  const parsedAmount = tryParseAmount('1', inputCurrency ?? undefined)\n\n  const bestTradeExactIn = useTradeExactIn(parsedAmount, outputCurrency ?? undefined)\n  if (!inputCurrency || !outputCurrency || !bestTradeExactIn) {\n    return null\n  }\n\n  const inputTokenPrice = parseFloat(bestTradeExactIn?.executionPrice?.toSignificant(6))\n  const outputTokenPrice = 1 / inputTokenPrice\n\n  return {\n    [token0Address]: inputTokenPrice,\n    [token1Address]: outputTokenPrice,\n  }\n}\n\n// from the current swap inputs, compute the best trade and return it.\nexport function useDerivedSwapInfo(\n  independentField: Field,\n  typedValue: string,\n  inputCurrency: Currency | undefined,\n  outputCurrency: Currency | undefined,\n  recipient: string,\n): {\n  currencies: { [field in Field]?: Currency }\n  currencyBalances: { [field in Field]?: CurrencyAmount<Currency> }\n  parsedAmount: CurrencyAmount<Currency> | undefined\n  v2Trade: Trade<Currency, Currency, TradeType> | undefined\n  inputError?: string\n} {\n  const { account } = useWeb3React()\n  const { t } = useTranslation()\n\n  const to: string | null = (recipient === null ? account : isAddress(recipient) || null) ?? null\n\n  const relevantTokenBalances = useCurrencyBalances(account ?? undefined, [\n    inputCurrency ?? undefined,\n    outputCurrency ?? undefined,\n  ])\n\n  const isExactIn: boolean = independentField === Field.INPUT\n  const parsedAmount = tryParseAmount(typedValue, (isExactIn ? inputCurrency : outputCurrency) ?? undefined)\n\n  const bestTradeExactIn = useTradeExactIn(isExactIn ? parsedAmount : undefined, outputCurrency ?? undefined)\n  const bestTradeExactOut = useTradeExactOut(inputCurrency ?? undefined, !isExactIn ? parsedAmount : undefined)\n\n  const v2Trade = isExactIn ? bestTradeExactIn : bestTradeExactOut\n\n  const currencyBalances = {\n    [Field.INPUT]: relevantTokenBalances[0],\n    [Field.OUTPUT]: relevantTokenBalances[1],\n  }\n\n  const currencies: { [field in Field]?: Currency } = {\n    [Field.INPUT]: inputCurrency ?? undefined,\n    [Field.OUTPUT]: outputCurrency ?? undefined,\n  }\n\n  let inputError: string | undefined\n  if (!account) {\n    inputError = t('Connect Wallet')\n  }\n\n  if (!parsedAmount) {\n    inputError = inputError ?? t('Enter an amount')\n  }\n\n  if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n    inputError = inputError ?? t('Select a token')\n  }\n\n  const formattedTo = isAddress(to)\n  if (!to || !formattedTo) {\n    inputError = inputError ?? t('Enter a recipient')\n  } else if (\n    BAD_RECIPIENT_ADDRESSES.indexOf(formattedTo) !== -1 ||\n    (bestTradeExactIn && involvesAddress(bestTradeExactIn, formattedTo)) ||\n    (bestTradeExactOut && involvesAddress(bestTradeExactOut, formattedTo))\n  ) {\n    inputError = inputError ?? t('Invalid recipient')\n  }\n\n  const [allowedSlippage] = useUserSlippageTolerance()\n\n  const slippageAdjustedAmounts = v2Trade && allowedSlippage && computeSlippageAdjustedAmounts(v2Trade, allowedSlippage)\n\n  // compare input balance to max input based on version\n  const [balanceIn, amountIn] = [\n    currencyBalances[Field.INPUT],\n    slippageAdjustedAmounts ? slippageAdjustedAmounts[Field.INPUT] : null,\n  ]\n\n  if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {\n    inputError = t('Insufficient %symbol% balance', { symbol: amountIn.currency.symbol })\n  }\n\n  return {\n    currencies,\n    currencyBalances,\n    parsedAmount,\n    v2Trade: v2Trade ?? undefined,\n    inputError,\n  }\n}\n\nfunction parseCurrencyFromURLParameter(urlParam: any): string {\n  if (typeof urlParam === 'string') {\n    const valid = isAddress(urlParam)\n    if (valid) return valid\n    if (urlParam.toUpperCase() === 'BNB') return 'BNB'\n    if (valid === false) return 'BNB'\n  }\n  return ''\n}\n\nfunction parseTokenAmountURLParameter(urlParam: any): string {\n  return typeof urlParam === 'string' && !Number.isNaN(parseFloat(urlParam)) ? urlParam : ''\n}\n\nfunction parseIndependentFieldURLParameter(urlParam: any): Field {\n  return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT\n}\n\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/\nfunction validatedRecipient(recipient: any): string | null {\n  if (typeof recipient !== 'string') return null\n  const address = isAddress(recipient)\n  if (address) return address\n  if (ADDRESS_REGEX.test(recipient)) return recipient\n  return null\n}\n\nexport function queryParametersToSwapState(\n  parsedQs: ParsedUrlQuery,\n  nativeSymbol?: string,\n  defaultOutputCurrency?: string,\n): SwapState {\n  let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency) || (nativeSymbol ?? DEFAULT_INPUT_CURRENCY)\n  let outputCurrency =\n    parseCurrencyFromURLParameter(parsedQs.outputCurrency) || (defaultOutputCurrency ?? DEFAULT_OUTPUT_CURRENCY)\n  if (inputCurrency === outputCurrency) {\n    if (typeof parsedQs.outputCurrency === 'string') {\n      inputCurrency = ''\n    } else {\n      outputCurrency = ''\n    }\n  }\n\n  const recipient = validatedRecipient(parsedQs.recipient)\n\n  return {\n    [Field.INPUT]: {\n      currencyId: inputCurrency,\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrency,\n    },\n    typedValue: parseTokenAmountURLParameter(parsedQs.exactAmount),\n    independentField: parseIndependentFieldURLParameter(parsedQs.exactField),\n    recipient,\n    pairDataById: {},\n    derivedPairDataById: {},\n  }\n}\n\n// updates the swap state to use the defaults for a given network\nexport function useDefaultsFromURLSearch():\n  | { inputCurrencyId: string | undefined; outputCurrencyId: string | undefined }\n  | undefined {\n  const { chainId } = useActiveWeb3React()\n  const dispatch = useAppDispatch()\n  const native = useNativeCurrency()\n  const { query } = useRouter()\n  const [result, setResult] = useState<\n    { inputCurrencyId: string | undefined; outputCurrencyId: string | undefined } | undefined\n  >()\n\n  useEffect(() => {\n    if (!chainId || !native) return\n    const parsed = queryParametersToSwapState(query, native.symbol, CAKE[chainId]?.address ?? USDC[chainId]?.address)\n\n    dispatch(\n      replaceSwapState({\n        typedValue: parsed.typedValue,\n        field: parsed.independentField,\n        inputCurrencyId: parsed[Field.INPUT].currencyId,\n        outputCurrencyId: parsed[Field.OUTPUT].currencyId,\n        recipient: null,\n      }),\n    )\n\n    setResult({ inputCurrencyId: parsed[Field.INPUT].currencyId, outputCurrencyId: parsed[Field.OUTPUT].currencyId })\n  }, [dispatch, chainId, query, native])\n\n  return result\n}\n\ntype useFetchPairPricesParams = {\n  token0Address: string\n  token1Address: string\n  timeWindow: PairDataTimeWindowEnum\n  currentSwapPrice: {\n    [key: string]: number\n  }\n}\n\nexport const useFetchPairPrices = ({\n  token0Address,\n  token1Address,\n  timeWindow,\n  currentSwapPrice,\n}: useFetchPairPricesParams) => {\n  const [pairId, setPairId] = useState(null)\n  const [isLoading, setIsLoading] = useState(false)\n  const pairData = useSelector(pairByDataIdSelector({ pairId, timeWindow }))\n  const derivedPairData = useSelector(derivedPairByDataIdSelector({ pairId, timeWindow }))\n  const dispatch = useDispatch()\n\n  useEffect(() => {\n    const fetchDerivedData = async () => {\n      console.info(\n        '[Price Chart]: Not possible to retrieve price data from single pool, trying to fetch derived prices',\n      )\n      try {\n        // Try to get at least derived data for chart\n        // This is used when there is no direct data for pool\n        // i.e. when multihops are necessary\n        const derivedData = await fetchDerivedPriceData(token0Address, token1Address, timeWindow)\n        if (derivedData) {\n          const normalizedDerivedData = normalizeDerivedChartData(derivedData)\n          dispatch(updateDerivedPairData({ pairData: normalizedDerivedData, pairId, timeWindow }))\n        } else {\n          dispatch(updateDerivedPairData({ pairData: [], pairId, timeWindow }))\n        }\n      } catch (error) {\n        console.error('Failed to fetch derived prices for chart', error)\n        dispatch(updateDerivedPairData({ pairData: [], pairId, timeWindow }))\n      } finally {\n        setIsLoading(false)\n      }\n    }\n\n    const fetchAndUpdatePairPrice = async () => {\n      setIsLoading(true)\n      const { data } = await fetchPairPriceData({ pairId, timeWindow })\n      if (data) {\n        // Find out if Liquidity Pool has enough liquidity\n        // low liquidity pool might mean that the price is incorrect\n        // in that case try to get derived price\n        const hasEnoughLiquidity = pairHasEnoughLiquidity(data, timeWindow)\n        const newPairData = normalizeChartData(data, timeWindow) || []\n        if (newPairData.length > 0 && hasEnoughLiquidity) {\n          dispatch(updatePairData({ pairData: newPairData, pairId, timeWindow }))\n          setIsLoading(false)\n        } else {\n          console.info(`[Price Chart]: Liquidity too low for ${pairId}`)\n          dispatch(updatePairData({ pairData: [], pairId, timeWindow }))\n          fetchDerivedData()\n        }\n      } else {\n        dispatch(updatePairData({ pairData: [], pairId, timeWindow }))\n        fetchDerivedData()\n      }\n    }\n\n    if (!pairData && !derivedPairData && pairId && !isLoading) {\n      fetchAndUpdatePairPrice()\n    }\n  }, [\n    pairId,\n    timeWindow,\n    pairData,\n    currentSwapPrice,\n    token0Address,\n    token1Address,\n    derivedPairData,\n    dispatch,\n    isLoading,\n  ])\n\n  useEffect(() => {\n    const updatePairId = () => {\n      try {\n        const pairAddress = getLpAddress(token0Address, token1Address)?.toLowerCase()\n        if (pairAddress !== pairId) {\n          setPairId(pairAddress)\n        }\n      } catch (error) {\n        setPairId(null)\n      }\n    }\n\n    updatePairId()\n  }, [token0Address, token1Address, pairId])\n\n  const normalizedPairData = useMemo(\n    () => normalizePairDataByActiveToken({ activeToken: token0Address, pairData }),\n    [token0Address, pairData],\n  )\n\n  const normalizedDerivedPairData = useMemo(\n    () => normalizeDerivedPairDataByActiveToken({ activeToken: token0Address, pairData: derivedPairData }),\n    [token0Address, derivedPairData],\n  )\n\n  const hasSwapPrice = currentSwapPrice && currentSwapPrice[token0Address] > 0\n\n  const normalizedPairDataWithCurrentSwapPrice =\n    normalizedPairData?.length > 0 && hasSwapPrice\n      ? [...normalizedPairData, { time: new Date(), value: currentSwapPrice[token0Address] }]\n      : normalizedPairData\n\n  const normalizedDerivedPairDataWithCurrentSwapPrice =\n    normalizedDerivedPairData?.length > 0 && hasSwapPrice\n      ? [...normalizedDerivedPairData, { time: new Date(), value: currentSwapPrice[token0Address] }]\n      : normalizedDerivedPairData\n\n  const hasNoDirectData = normalizedPairDataWithCurrentSwapPrice && normalizedPairDataWithCurrentSwapPrice?.length === 0\n  const hasNoDerivedData =\n    normalizedDerivedPairDataWithCurrentSwapPrice && normalizedDerivedPairDataWithCurrentSwapPrice?.length === 0\n\n  // undefined is used for loading\n  let pairPrices = hasNoDirectData && hasNoDerivedData ? [] : undefined\n  if (normalizedPairDataWithCurrentSwapPrice && normalizedPairDataWithCurrentSwapPrice?.length > 0) {\n    pairPrices = normalizedPairDataWithCurrentSwapPrice\n  } else if (\n    normalizedDerivedPairDataWithCurrentSwapPrice &&\n    normalizedDerivedPairDataWithCurrentSwapPrice?.length > 0\n  ) {\n    pairPrices = normalizedDerivedPairDataWithCurrentSwapPrice\n  }\n  return { pairPrices, pairId }\n}\n\nexport const useLPApr = (pair?: Pair) => {\n  const { data: poolData } = useSWRImmutable(\n    pair && pair.chainId === ChainId.PULSE_CHAIN ? ['LP7dApr', pair.liquidityToken.address] : null,\n    async () => {\n      const timestampsArray = getDeltaTimestamps()\n      const blocks = await getBlocksFromTimestamps(timestampsArray, 'desc', 1000)\n      const [block24h, block48h, block7d, block14d] = blocks ?? []\n      const { error, data } = await fetchPoolData(block24h.number, block48h.number, block7d.number, block14d.number, [\n        pair.liquidityToken.address.toLowerCase(),\n      ])\n      if (error) return null\n      const formattedPoolData = parsePoolData(data?.now)\n      const formattedPoolData24h = parsePoolData(data?.oneDayAgo)\n      const formattedPoolData48h = parsePoolData(data?.twoDaysAgo)\n      const formattedPoolData7d = parsePoolData(data?.oneWeekAgo)\n      const formattedPoolData14d = parsePoolData(data?.twoWeeksAgo)\n      const current: FormattedPoolFields | undefined = formattedPoolData[pair.liquidityToken.address.toLowerCase()]\n      const oneDay: FormattedPoolFields | undefined = formattedPoolData24h[pair.liquidityToken.address.toLowerCase()]\n      const twoDays: FormattedPoolFields | undefined = formattedPoolData48h[pair.liquidityToken.address.toLowerCase()]\n      const week: FormattedPoolFields | undefined = formattedPoolData7d[pair.liquidityToken.address.toLowerCase()]\n      const twoWeeks: FormattedPoolFields | undefined = formattedPoolData14d[pair.liquidityToken.address.toLowerCase()]\n      const [volumeUSD] = getChangeForPeriod(current?.volumeUSD, oneDay?.volumeUSD, twoDays?.volumeUSD)\n      const [volumeUSDWeek] = getChangeForPeriod(current?.volumeUSD, week?.volumeUSD, twoWeeks?.volumeUSD)\n      const liquidityUSD = current ? current.reserveUSD : 0\n      const { lpApr7d } = getLpFeesAndApr(volumeUSD, volumeUSDWeek, liquidityUSD)\n      return lpApr7d ? { lpApr7d } : null\n    },\n    {\n      refreshInterval: SLOW_INTERVAL,\n    },\n  )\n\n  return poolData\n}\n","import get from 'lodash/get'\nimport { AppState } from 'state'\nimport { PairDataTimeWindowEnum } from './types'\n\ntype pairByDataIdSelectorParams = {\n  pairId: string\n  timeWindow: PairDataTimeWindowEnum\n}\n\nexport const pairByDataIdSelector =\n  ({ pairId, timeWindow }: pairByDataIdSelectorParams) =>\n  (state: AppState) =>\n    get(state, ['swap', 'pairDataById', pairId, timeWindow])\n\nexport const derivedPairByDataIdSelector =\n  ({ pairId, timeWindow }: pairByDataIdSelectorParams) =>\n  (state: AppState) =>\n    get(state, ['swap', 'derivedPairDataById', pairId, timeWindow])\n","import { fromUnixTime } from 'date-fns'\nimport fromPairs from 'lodash/fromPairs'\nimport { PairDayDatasResponse, PairHoursDatasResponse } from './fetch/types'\nimport { DerivedPairDataNormalized, PairDataNormalized, PairDataTimeWindowEnum, PairPricesNormalized } from './types'\n\nexport const normalizeChartData = (\n  data: PairHoursDatasResponse | PairDayDatasResponse | null,\n  timeWindow: PairDataTimeWindowEnum,\n) => {\n  switch (timeWindow) {\n    case PairDataTimeWindowEnum.DAY:\n    case PairDataTimeWindowEnum.WEEK:\n      return (data as PairHoursDatasResponse)?.pairHourDatas?.map((fetchPairEntry) => ({\n        time: fetchPairEntry.hourStartUnix,\n        token0Id: fetchPairEntry.pair.token0.id,\n        token1Id: fetchPairEntry.pair.token1.id,\n        reserve0: parseFloat(fetchPairEntry.reserve0),\n        reserve1: parseFloat(fetchPairEntry.reserve1),\n      }))\n    case PairDataTimeWindowEnum.MONTH:\n    case PairDataTimeWindowEnum.YEAR:\n      return (data as PairDayDatasResponse)?.pairDayDatas?.map((fetchPairEntry) => ({\n        time: fetchPairEntry.date,\n        token0Id: fetchPairEntry.pairAddress.token0.id,\n        token1Id: fetchPairEntry.pairAddress.token1.id,\n        reserve0: parseFloat(fetchPairEntry.reserve0),\n        reserve1: parseFloat(fetchPairEntry.reserve1),\n      }))\n    default:\n      return null\n  }\n}\n\nexport const normalizeDerivedChartData = (data: any) => {\n  if (!data?.token0DerivedBnb || data?.token0DerivedBnb.length === 0) {\n    return []\n  }\n\n  const token1DerivedBnbEntryMap: any = fromPairs(\n    data?.token1DerivedBnb?.map((entry) => [entry.timestamp, entry]) ?? [],\n  )\n\n  return data?.token0DerivedBnb.reduce((acc, token0DerivedBnbEntry) => {\n    const token1DerivedBnbEntry = token1DerivedBnbEntryMap[token0DerivedBnbEntry.timestamp]\n    if (token1DerivedBnbEntry) {\n      acc.push({\n        time: parseInt(token0DerivedBnbEntry.timestamp, 10),\n        token0Id: token0DerivedBnbEntry.tokenAddress,\n        token1Id: token1DerivedBnbEntry.tokenAddress,\n        token0DerivedBNB: token0DerivedBnbEntry.derivedETH,\n        token1DerivedBNB: token1DerivedBnbEntry.derivedETH,\n      })\n    }\n    return acc\n  }, [])\n}\n\ntype normalizePairDataByActiveTokenParams = {\n  pairData: PairDataNormalized\n  activeToken: string\n}\n\nexport const normalizePairDataByActiveToken = ({\n  pairData,\n  activeToken,\n}: normalizePairDataByActiveTokenParams): PairPricesNormalized =>\n  pairData\n    ?.map((pairPrice) => ({\n      time: fromUnixTime(pairPrice.time),\n      value:\n        activeToken === pairPrice?.token0Id\n          ? pairPrice.reserve1 / pairPrice.reserve0\n          : pairPrice.reserve0 / pairPrice.reserve1,\n    }))\n    .reverse()\n\ntype normalizeDerivedPairDataByActiveTokenParams = {\n  pairData: DerivedPairDataNormalized\n  activeToken: string\n}\n\nexport const normalizeDerivedPairDataByActiveToken = ({\n  pairData,\n  activeToken,\n}: normalizeDerivedPairDataByActiveTokenParams): PairPricesNormalized =>\n  pairData?.map((pairPrice) => ({\n    time: fromUnixTime(pairPrice.time),\n    value:\n      activeToken === pairPrice?.token0Id\n        ? pairPrice.token0DerivedBNB / pairPrice.token1DerivedBNB\n        : pairPrice.token1DerivedBNB / pairPrice.token0DerivedBNB,\n  }))\n","export type PairDataNormalized = {\n  time: number\n  token0Id: string\n  token1Id: string\n  reserve0: number\n  reserve1: number\n}[]\n\nexport type DerivedPairDataNormalized = {\n  time: number\n  token0Id: string\n  token1Id: string\n  token0DerivedBNB: number\n  token1DerivedBNB: number\n}[]\n\nexport type PairPricesNormalized = {\n  time: Date\n  value: number\n}[]\n\nexport enum PairDataTimeWindowEnum {\n  DAY,\n  WEEK,\n  MONTH,\n  YEAR,\n}\n","import { Currency } from '@pancakeswap/sdk'\n\nexport function currencyId(currency: Currency): string {\n  if (currency?.isNative) return currency.symbol?.toUpperCase()\n  if (currency?.isToken) return currency.address\n  throw new Error('invalid currency')\n}\n\nexport default currencyId\n","import { Currency, CurrencyAmount, Fraction, JSBI, Percent, Trade, TradeType } from '@pancakeswap/sdk'\nimport IPancakeRouter02ABI from 'config/abi/IPancakeRouter02.json'\nimport { IPancakeRouter02 } from 'config/abi/types/IPancakeRouter02'\nimport {\n  ALLOWED_PRICE_IMPACT_HIGH,\n  ALLOWED_PRICE_IMPACT_LOW,\n  ALLOWED_PRICE_IMPACT_MEDIUM,\n  BIPS_BASE,\n  BLOCKED_PRICE_IMPACT_NON_EXPERT,\n  INPUT_FRACTION_AFTER_FEE,\n  ONE_HUNDRED_PERCENT,\n  ROUTER_ADDRESS,\n} from 'config/constants/exchange'\nimport { useActiveChainId } from 'hooks/useActiveChainId'\nimport { useContract } from 'hooks/useContract'\nimport { StableTrade } from 'views/Swap/StableSwap/hooks/useStableTradeExactIn'\nimport { Field } from '../state/swap/actions'\n\n// converts a basis points value to a sdk percent\nexport function basisPointsToPercent(num: number): Percent {\n  return new Percent(JSBI.BigInt(num), BIPS_BASE)\n}\n\nexport function calculateSlippageAmount(value: CurrencyAmount<Currency>, slippage: number): [JSBI, JSBI] {\n  if (slippage < 0 || slippage > 10000) {\n    throw Error(`Unexpected slippage value: ${slippage}`)\n  }\n  return [\n    JSBI.divide(JSBI.multiply(value.quotient, JSBI.BigInt(10000 - slippage)), BIPS_BASE),\n    JSBI.divide(JSBI.multiply(value.quotient, JSBI.BigInt(10000 + slippage)), BIPS_BASE),\n  ]\n}\n\nexport function useRouterContract() {\n  const { chainId } = useActiveChainId()\n  return useContract<IPancakeRouter02>(ROUTER_ADDRESS[chainId], IPancakeRouter02ABI, true)\n}\n\n// computes price breakdown for the trade\nexport function computeTradePriceBreakdown(trade?: Trade<Currency, Currency, TradeType> | null): {\n  priceImpactWithoutFee: Percent | undefined\n  realizedLPFee: CurrencyAmount<Currency> | undefined | null\n} {\n  // for each hop in our trade, take away the x*y=k price impact from 0.3% fees\n  // e.g. for 3 tokens/2 hops: 1 - ((1 - .03) * (1-.03))\n  const realizedLPFee = !trade\n    ? undefined\n    : ONE_HUNDRED_PERCENT.subtract(\n        trade.route.pairs.reduce<Fraction>(\n          (currentFee: Fraction): Fraction => currentFee.multiply(INPUT_FRACTION_AFTER_FEE),\n          ONE_HUNDRED_PERCENT,\n        ),\n      )\n\n  // remove lp fees from price impact\n  const priceImpactWithoutFeeFraction = trade && realizedLPFee ? trade.priceImpact.subtract(realizedLPFee) : undefined\n\n  // the x*y=k impact\n  const priceImpactWithoutFeePercent = priceImpactWithoutFeeFraction\n    ? new Percent(priceImpactWithoutFeeFraction?.numerator, priceImpactWithoutFeeFraction?.denominator)\n    : undefined\n\n  // the amount of the input that accrues to LPs\n  const realizedLPFeeAmount =\n    realizedLPFee &&\n    trade &&\n    CurrencyAmount.fromRawAmount(\n      trade.inputAmount.currency,\n      realizedLPFee.multiply(trade.inputAmount.quotient).quotient,\n    )\n\n  return { priceImpactWithoutFee: priceImpactWithoutFeePercent, realizedLPFee: realizedLPFeeAmount }\n}\n\n// computes the minimum amount out and maximum amount in for a trade given a user specified allowed slippage in bips\nexport function computeSlippageAdjustedAmounts(\n  trade: Trade<Currency, Currency, TradeType> | StableTrade | undefined,\n  allowedSlippage: number,\n): { [field in Field]?: CurrencyAmount<Currency> } {\n  const pct = basisPointsToPercent(allowedSlippage)\n  return {\n    [Field.INPUT]: trade?.maximumAmountIn(pct),\n    [Field.OUTPUT]: trade?.minimumAmountOut(pct),\n  }\n}\n\nexport function warningSeverity(priceImpact: Percent | undefined): 0 | 1 | 2 | 3 | 4 {\n  if (!priceImpact?.lessThan(BLOCKED_PRICE_IMPACT_NON_EXPERT)) return 4\n  if (!priceImpact?.lessThan(ALLOWED_PRICE_IMPACT_HIGH)) return 3\n  if (!priceImpact?.lessThan(ALLOWED_PRICE_IMPACT_MEDIUM)) return 2\n  if (!priceImpact?.lessThan(ALLOWED_PRICE_IMPACT_LOW)) return 1\n  return 0\n}\n\nexport function formatExecutionPrice(trade?: Trade<Currency, Currency, TradeType>, inverted?: boolean): string {\n  if (!trade) {\n    return ''\n  }\n  return inverted\n    ? `${trade.executionPrice.invert().toSignificant(6)} ${trade.inputAmount.currency.symbol} / ${\n        trade.outputAmount.currency.symbol\n      }`\n    : `${trade.executionPrice.toSignificant(6)} ${trade.outputAmount.currency.symbol} / ${\n        trade.inputAmount.currency.symbol\n      }`\n}\n","// BNB Address\nconst BNB_ADDRESS = '0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c'\n\nexport { BNB_ADDRESS }\n","import { BNB_ADDRESS } from './constants'\n\nconst MIN_VALUE_DISPLAYED = 0.001\n\nexport const getTimeWindowChange = (lineChartData) => {\n  if (lineChartData.length > 0) {\n    const firstValue = lineChartData.find(({ value }) => !!value && value > 0)?.value ?? 0\n    const lastValue = lineChartData[lineChartData.length - 1].value\n    const changeValue = lastValue - firstValue\n\n    return {\n      changeValue:\n        changeValue > 0 ? Math.max(changeValue, MIN_VALUE_DISPLAYED) : Math.min(changeValue, MIN_VALUE_DISPLAYED * -1),\n      changePercentage: ((changeValue / firstValue) * 100).toFixed(2),\n    }\n  }\n\n  return {\n    changeValue: 0,\n    changePercentage: 0,\n  }\n}\n\nexport const getTokenAddress = (tokenAddress: undefined | string) => {\n  if (!tokenAddress) {\n    return ''\n  }\n  const lowerCaseAddress = tokenAddress.toLowerCase()\n  if (lowerCaseAddress === 'bnb') {\n    return BNB_ADDRESS\n  }\n\n  return lowerCaseAddress\n}\n"],"names":["props","_jsx","Svg","_object_spread_props","_object_spread","viewBox","children","href","width","height","d","value","currency","typedValueParsed","parseUnits","decimals","toString","CurrencyAmount","JSBI","error","console","debug","uriToHttp","uri","split","toLowerCase","substring","hash","match","name","mapping","ChainId","token","chainId","address","StyledLogo","styled","Logo","size","CurrencyLogo","style","uriLocations","useHttpLocations","WrappedTokenInfo","logoURI","undefined","srcs","useMemo","isNative","isToken","tokenLogoURL","getTokenLogoURL","BinanceIcon","alt","symbol","BAD_SRCS","rest","refresh","useState","src","find","s","img","onError","i","HelpIcon","Wrapper","margin","DoubleCurrencyLogo","currency0","currency1","marginRight","StyledListLogo","ListLogo","isTradeBetter","tradeA","tradeB","minimumDelta","ZERO_PERCENT","tradeType","inputAmount","equals","outputAmount","Error","equalTo","executionPrice","lessThan","asFraction","multiply","add","ONE_HUNDRED_PERCENT","useAllCommonPairs","currencyA","currencyB","useActiveWeb3React","wrappedCurrency","tokenA","tokenB","bases","ADDITIONAL_BASES","BASES_TO_CHECK_TRADES_AGAINST","common","additionalA","additionalB","basePairs","flatMap","base","map","otherBase","allPairCombinations","filter","tokens","Boolean","t0","t1","tokenA_","tokenB_","customBases","CUSTOM_BASES","customBasesA","customBasesB","allPairs","usePairs","Object","values","result","PairState","reduce","memo","curr","liquidityToken","useTradeExactIn","currencyAmountIn","currencyOut","allowedPairs","singleHopOnly","useUserSingleHopOnly","length","Trade","maxHops","maxNumResults","bestTradeSoFar","currentTrade","BETTER_TRADE_LESS_HOPS_THRESHOLD","useTradeExactOut","currencyIn","currencyAmountOut","useIsTransactionUnsupported","unsupportedTokens","useUnsupportedTokens","tokenIn","tokenOut","keys","includes","useIsTransactionWarning","useWarningTokens","gql","timeWindowIdsCountMapping","PairDataTimeWindowEnum","timeWindowGapMapping","getPairSequentialId","id","pairId","replace","getIdsByTimeWindow","pairAddress","pairLastId","timeWindow","idsCount","pairLastIdAsNumber","Number","times","fetchPairPriceData","client","lastPairHourIdData","lastId","pairHourId","pairHourIds","lastPairDayIdData","pairDayIds","infoClient","requestWithTimeout","pairHourDatas","first","data","lastPairHourId","pairHourDatasByIds","pairIds","pairDayDatas","lastPairDayId","pairDayDatasByIdsQuery","getDerivedPrices","tokenAddress","blocks","block","timestamp","number","getDerivedPricesQueryConstructor","subqueries","getTokenDerivedBnbPrices","prices","tokenPrices","multiQuery","INFO_CLIENT","forEach","priceKey","push","derivedETH","parseFloat","orderBy","tokenPrice","parseInt","getSkipDaysToStart","fetchDerivedPriceData","token0Address","token1Address","interval","endTimestamp","startTimestamp","timestamps","time","token0DerivedBnb","token1DerivedBnb","ONE_HOUR_SECONDS","ONE_DAY_UNIX","getInterval","getUnixTime","Date","startOfHour","sub","days","getBlocksFromTimestamps","Promise","all","useSwapState","useSelector","state","swap","BAD_RECIPIENT_ADDRESSES","involvesAddress","trade","checksummedAddress","route","path","some","pairs","pair","useSingleTokenSwapInfo","inputCurrencyId","inputCurrency","outputCurrencyId","outputCurrency","bestTradeExactIn","getTokenAddress","parsedAmount","tryParseAmount","inputTokenPrice","toSignificant","outputTokenPrice","useDerivedSwapInfo","independentField","typedValue","recipient","isExactIn","inputError","useWeb3React","account","useTranslation","t","to","isAddress","relevantTokenBalances","useCurrencyBalances","Field","bestTradeExactOut","v2Trade","currencyBalances","currencies","formattedTo","indexOf","allowedSlippage","useUserSlippageTolerance","slippageAdjustedAmounts","computeSlippageAdjustedAmounts","balanceIn","amountIn","parseCurrencyFromURLParameter","urlParam","valid","toUpperCase","ADDRESS_REGEX","queryParametersToSwapState","parsedQs","nativeSymbol","defaultOutputCurrency","DEFAULT_INPUT_CURRENCY","DEFAULT_OUTPUT_CURRENCY","test","validatedRecipient","currencyId","exactAmount","isNaN","parseIndependentFieldURLParameter","exactField","pairDataById","derivedPairDataById","useDefaultsFromURLSearch","dispatch","useAppDispatch","native","useNativeCurrency","useRouter","query","setResult","useEffect","CAKE","USDC","parsed","replaceSwapState","field","useFetchPairPrices","currentSwapPrice","setPairId","isLoading","setIsLoading","pairData","get","pairByDataIdSelector","derivedPairData","derivedPairByDataIdSelector","useDispatch","fetchDerivedData","derivedData","normalizedDerivedData","info","token1DerivedBnbEntryMap","fromPairs","entry","acc","token0DerivedBnbEntry","token1DerivedBnbEntry","token0Id","token1Id","token0DerivedBNB","token1DerivedBNB","normalizeDerivedChartData","updateDerivedPairData","fetchAndUpdatePairPrice","hasEnoughLiquidity","newPairData","amountOfDataPoints","totalLiquidity","fetchPairEntry","reserveUSD","pairHasEnoughLiquidity","hourStartUnix","token0","token1","reserve0","reserve1","date","normalizeChartData","updatePairData","getLpAddress","updatePairId","normalizedPairData","activeToken","pairPrice","fromUnixTime","reverse","normalizePairDataByActiveToken","normalizedDerivedPairData","normalizeDerivedPairDataByActiveToken","hasSwapPrice","normalizedPairDataWithCurrentSwapPrice","normalizedDerivedPairDataWithCurrentSwapPrice","hasNoDirectData","hasNoDerivedData","pairPrices","useLPApr","useSWRImmutable","timestampsArray","block24h","block48h","block7d","block14d","formattedPoolData","formattedPoolData24h","formattedPoolData48h","formattedPoolData7d","formattedPoolData14d","current","oneDay","twoDays","week","twoWeeks","getChangeForPeriod","volumeUSD","volumeUSDWeek","liquidityUSD","lpApr7d","getDeltaTimestamps","fetchPoolData","parsePoolData","now","oneDayAgo","twoDaysAgo","oneWeekAgo","twoWeeksAgo","getLpFeesAndApr","refreshInterval","SLOW_INTERVAL","DAY","WEEK","MONTH","YEAR","basisPointsToPercent","num","Percent","BIPS_BASE","calculateSlippageAmount","slippage","quotient","useRouterContract","useActiveChainId","useContract","ROUTER_ADDRESS","IPancakeRouter02ABI","computeTradePriceBreakdown","realizedLPFee","currentFee","INPUT_FRACTION_AFTER_FEE","priceImpactWithoutFeeFraction","priceImpact","subtract","priceImpactWithoutFee","numerator","denominator","pct","maximumAmountIn","minimumAmountOut","warningSeverity","BLOCKED_PRICE_IMPACT_NON_EXPERT","ALLOWED_PRICE_IMPACT_HIGH","ALLOWED_PRICE_IMPACT_MEDIUM","ALLOWED_PRICE_IMPACT_LOW","formatExecutionPrice","inverted","invert","BNB_ADDRESS","getTimeWindowChange","lineChartData","firstValue","changeValue","Math","max","min","MIN_VALUE_DISPLAYED","changePercentage","toFixed","lowerCaseAddress"],"sourceRoot":""}